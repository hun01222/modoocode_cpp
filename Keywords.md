# ModooCode Keyword 모음집

## Basic

### 이름 공간(namespace)

- 정의된 객체에 대해 어디 소속인지 지정해주는 것
    
#### 이름 없는 이름공간

- static 키워드를 사용한 것과 동일한 효과를 낸다.
- static 키워드를 함수에 선언하면 해당 소스파일에서만 사용 가능하게 한다.

### reference

```cpp
int *pi = &i;
```
에서

- &#42; 은 참조연산자 : 포인터 선언, 메모리 접근에 사용
- & 은 주소연산자 : 해당 변수의 주소값 반환
 
`int& another_a = a;`
에서

- another_a 는 a 의 레퍼런스 (별명)
  - 레퍼런스는 누구의 별명이 될 것인지 지정해야 한다.
  - 한번 레퍼런스로 지정이 되면 절대로 다른 변수의 레퍼런스가 될 수 없다.
  - 레퍼런스는 메모리 상에 존재하지 않을 수 있다.
  - 참조자를 사용하게 되면 불필요한 &#42; 와 & 을 쓰지 않아도 된다.
  - Dangling reference : 지역 변수의 레퍼런스를 리턴하지 않도록 조심해야 한다.
  
### malloc

```cpp
int* p=new int;
delete p;
```

- new 는 생성자를 호출한다 cf) malloc 은 그렇지 않다.

### class

#### 객체

- 변수들과 자료들로 이루어진 소프트웨어 덩어리
- 인스턴스 : 클래스를 이용해서 만들어진 객체
- 추상화 : 객체가 현실 세계에서의 존재하는 것들을 나타내기 위한 과정
- 캡슐화 : 외부에서 직접 인스턴스 변수의 값을 바꿀 수 없고 인스턴스 매소드를 통해 간접적으로 조절하는 것
- 매소드 호출 시 객체면 . 포인터면 ->

## OOP

### overloading

- c++ 에서는 같은 이름을 가진 함수가 여러개 존재해도 된다.
- 함수의 이름이 같더라도 인자가 다르면 다른 함수이다.

### constructor

- 객체 생성시 자동으로 호출되는 함수
	`Con(int a, int b, int c);`
- 생성자도 오버로딩이 가능하다

#### default constructor

- 인자를 하나도 가지지 않는 생성자
  `Con();`
- 명시적으로 사용
  `con() = default;`
  
### destructor

- 객체 소멸시 자동으로 호출되는 함수
  `~Con()`
- 메모리 누수 : 메모리를 해재해 주지 않으면 발생
- default 소멸자도 존재한다

### copy constructor

- 동일한 객체 하나로 나머지 객체를 복사 생성
  `Con(const con& c);`
- 함수 내부에서 받은 인자의 값을 변화시키는 일이 없다면 const 를 붙혀주는 것이 바람직하다.

#### default copy constructor

- 디폴트 복사 생성자를 사용했을 때 얕은 복사를 하게 되면 배열 같은 경우 같은 주소값을 가질 수 있다.
- 깊은 복사 : 새로 할당해서 내용을 복사하는 것
- 얕은 복사 : 단순히 대입만 해 주는 것

### initializer list

- 생성자 호출과 동시에 멤버 변수들을 초기화
  `Con(int a, int b) : a_(a), b_(b), c(0), d(false) {}`
- 초기화 리스트를 사용하지 않으면 생성을 먼저 하고  그 다음에 대입 수행
- 상수와 레퍼런스들은 모두 생성과 동시에 초기화 되어야 하므로 초기화 리스트가 필요하다.

### static 변수

- 클래스 자체에만 종속되는 변수
- static 함수 또한 클래스 자체에 종속되는 함수

### this

- 객체 자신을 가리키는 포인터

### const 함수

- 다른 변수의 값을 바꾸지 않는 함수
  `Con() const {}`

### explicit

- 암시적 변환 : 타입이 다르면 적절히 다른 타입으로 변환하여 컴파일 한다.
- explicit 키워드 사용하면 원하지 않는 암시적 변환을 할 수 없도록 컴파일러에 명시한다.
  `explicit Con() {}`
- explicit 키워드는 또한 해당 생성자가 복사 생성자의 형태로도 호출되는 것을 막게 한다.

### mutable

- const 함수 안에서 해당 멤버 변수에 const 가 아닌 작업을 할 수 있게 만들어준다.
  `mutable A a;`

## Overloading

- 오버로딩 : 기본 연산자들을 직접 사용자가 정의하는 것
- ::(범위 지정), .(멤버 지정), .&#42;(멤버 포인터로 멤버 지정) 을 제외한 모든 연산자를 사용할 수 있다.

### 대입 연산자 함수

- `C operator=(const C& c) {}`
- 디폴트 복사 생성자 처럼 디폴트 대입 연산자도 존재한다

### friend

- friend 키워드를 사용하면 private 이냐 public 이냐에 관계 없이 내부 정보에 접근할 수 있다.
  `friend C operator+(const C& a, const C& b) {}`
- 함수 뿐만 아니라 다른 클래스 자체도 friend 로 지정할 수 있다.
  ```cpp
  class A {
   private:
    friend B;
  }```

### Wrapper 클래스

- 기본 자료형들을 클래스로 포장하여 각각의 자료형을 객체로 사용하는 것
  - 타입 변환 연산자
  `operator int()`
  
### c++ 스타일의 캐스팅

- 종류
  - static_cast : 일반적인 타입 변환
  - const_cast : 객체의 상수성을 없애는 타입 변환. const int 가 int 로 바뀐다.
  - dynamic_cast : 파생 클래스 사이에서의 다운 캐스팅
  - reinterpret_cast : 위험을 감수하고 하는 캐스팅으로 서로 관련이 없는 포인터들 사이의 캐스팅 등
- `static_cast<int>(float_variable)` 은 c언어 에서의 `(int)(float_veriable)` 과 동일한 문장이다.

- A** 타입은 A* 객체를 배열로 사용하는 경우 사용할 수 있다.

## Inheritance

- 상속 : 다른 클래스의 내용을 그대로 포함할 수 있게 한다.
- c++ 의 경우 여러 명의 부모를 가질 수 있기에 부모, 자식 클래스보다 기반, 파생 클래스라고 부르는 것이 낫다.
- 오버라이딩(overriding) : 같은 이름의 함수라도 다른 클래스에 정의되어 있으면 다른 함수로 취급된다.

### protected

- 상속받는 클래스에서는 접근 가능하고 그 외의 기타 정보는 접근 불가능

- `class Derived : public Base` 에서
  - public 으로 상속 : 그대로 작동
  - protected 로 상속 : public 은 protected 로 바뀌고 나머지는 그대로 작동
  - pravate 로 상속 : 모든 접근 지시자들이 private 가 됨
  
### virtual

- 업 캐스팅 : 파생 클래스에서 기반 클래스로 캐스팅
- 다운 캐스팅 : 기반 클래스에서 파생 클래스로 캐스팅
- virtual : 런타임 시에 해당 객체에 해당하는 함수가 오버라이딩 되어 실행된다.
	`virtual void Con() {}`
  - 동적 바인딩 : 런타임 시에 어떤 함수가 실행될지 정해진다.
  - 정적 바인딩 : 컴파일 시에 어떤 함수가 실행될지 정해진다.
  
#### 가상 함수의 구현 원리

- c++ 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해서 **가상 함수 테이블**을 만드렉 된다.
- 이를 사용해서 동적 바인딩을 구현한다. 따라서 한 단계를 더 거침으로 약간의 오버해드가 발생한다.
  
#### virtual 소멸자

- 상속 시에, 소멸자를 가상함수로 만들어야 한다.
  ```cpp
  class Parent {
   public:
    Parent()
    virtual ~Parent()
  };
  class Child : public Parent {
   public:
    Child() : Parent()
    ~Child()
  };
  ```
  이렇게 해야 Child 의 소멸자를 성공적으로 호출할 수 있다.
  
#### 순수 가상 함수

- 반드시 오버라이딩 되어야 하는 함수이다.
  `virtual void Con() = 0;`
- 순수 가상 함수가 있는 클래스의 객체 생성은 불가능하다.
- 추상 클래스 : 순수 가상 함수를 최소 한개 포함하고 있는 클래스이다. 따라서 반드시 상속 되어야 한다.

### override

- 파생 클래스에서 기반 클래스의 가상 함수를 오버라이드 하는 경우, override 키워드를 통해 명시적으로 나타낼 수 있다.
  `void Con() override {}`
- override 키워드를 이용하면, 실수로 오버라이드를 하지 않는 경우를 막을 수 있다.

### polymorphism

- 하나의 메소드를 호출했음에도 불구하고 클래스에 따라 여러가지 다른 작업들을 하는 것

### 다중 상속 (multiple inheritance)

- 한 클래스가 다른 여러 개의 클래스들을 상속 받는 것
  `class C : public A, public B {};`

#### 다중 상속 시 주의할 점

- 상속 받는 클래스에 동일한 이름의 변수가 있을 경우
- 다이아몬드 상속 : 상속이 되는 두 개의 클래스가 공통의 기반 클래스를 포함한다. 따라서 변수가 겹치는 경우가 발생
  ```cpp
  class A {};
  class B : public virtual A {};
  class C : public virtual A {};
  class D : public B, public C {};
  ```
  
#### 클래스 디자인 패턴

- 브릿지 패턴 : 각각의 클래스(N)에서 각각의 클래스의(M) 맴버 변수로 제어
  - N + M 의 클래스 생성
  - 섬세한 제어 안됨
  - M 으로 N 을 표현 못함
- 중첩된 일반화 방식 : 모든 클래스를 다 만듬 (N&#42;M)
  - 최대 N &#42; M 의 클래스 생성
  - 섬세한 제어 가능
  - M 으로 N 을 표현 못함
- 다중 상속
  -	최대 N &#42; M 의 클래스 생성
  - 섬세한 제어 가능
  - M 으로 N 표현 가능
  
## Standard io library

### iostream

- ios_base 클래스 : 스트림의 입출력 형식 관련 데이터 처리 (실수 형의 정밀도, 정수형 출력시 진법 처리)
- ios 클래스 : 스트림 버퍼를 초기화, 현재 입출력 작업의 상태를 처리 (eof 함수, good 함수 : 현재 입출력 작업을 잘 처리할 수 있는지)